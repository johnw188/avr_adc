
adc_test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000014c  00800100  00000b8c  00000c00  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000b8c  00000000  00000000  00000074  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .stab         00002934  00000000  00000000  00000d4c  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      000028b1  00000000  00000000  00003680  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
   4:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
   8:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
   c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  10:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  14:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  18:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  1c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  20:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  24:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  28:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  2c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  30:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  34:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  38:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  3c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  40:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  44:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  48:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  4c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  50:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  54:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  58:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  5c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  60:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  64:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  68:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  6c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  70:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  74:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  78:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  7c:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  80:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  84:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>
  88:	0c 94 63 00 	jmp	0xc6	; 0xc6 <__bad_interrupt>

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e1       	ldi	r29, 0x10	; 16
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	12 e0       	ldi	r17, 0x02	; 2
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	ec e8       	ldi	r30, 0x8C	; 140
  a0:	fb e0       	ldi	r31, 0x0B	; 11
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	ac 34       	cpi	r26, 0x4C	; 76
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	12 e0       	ldi	r17, 0x02	; 2
  b4:	ac e4       	ldi	r26, 0x4C	; 76
  b6:	b2 e0       	ldi	r27, 0x02	; 2
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	ac 34       	cpi	r26, 0x4C	; 76
  be:	b1 07       	cpc	r27, r17
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	0c 94 65 00 	jmp	0xca	; 0xca <main>

000000c6 <__bad_interrupt>:
  c6:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>

000000ca <main>:
 *  (after standard setup code has finished). For mechatronics programs, main() runs an
 *  infinite loop and never exits. 
 */

int main ()
  ca:	c0 ef       	ldi	r28, 0xF0	; 240
  cc:	d0 e1       	ldi	r29, 0x10	; 16
  ce:	de bf       	out	0x3e, r29	; 62
  d0:	cd bf       	out	0x3d, r28	; 61
    {
    volatile unsigned long dummy;           // Used as a not-smart delay loop counter
    unsigned char channel_count = 0;        // Counts through the channels
    unsigned int conversion;                // Data from the A/D

    // Create an RS232 serial port object. Diagnostic information can be printed out 
    // using this port
    rs232 the_serial_port (BAUD_DIV, 1);
  d2:	8e 01       	movw	r16, r28
  d4:	09 5f       	subi	r16, 0xF9	; 249
  d6:	1f 4f       	sbci	r17, 0xFF	; 255
  d8:	41 e0       	ldi	r20, 0x01	; 1
  da:	6a e1       	ldi	r22, 0x1A	; 26
  dc:	c8 01       	movw	r24, r16
  de:	0e 94 b8 03 	call	0x770	; 0x770 <_ZN5rs232C1Ehh>

    // Create an ADC (Analog to Digital Converter) object. This object must be given a
    // pointer to the serial port object so that it can print debugging information
    avr_adc my_adc (&the_serial_port);
  e2:	b8 01       	movw	r22, r16
  e4:	6e 01       	movw	r12, r28
  e6:	08 94       	sec
  e8:	c1 1c       	adc	r12, r1
  ea:	d1 1c       	adc	r13, r1
  ec:	c6 01       	movw	r24, r12
  ee:	0e 94 3e 04 	call	0x87c	; 0x87c <_ZN7avr_adcC1EP16base_text_serial>

    // Say hello
    the_serial_port << "\r\nAnalog to Digital Test Program v0.002\r\n";
  f2:	60 e0       	ldi	r22, 0x00	; 0
  f4:	71 e0       	ldi	r23, 0x01	; 1
  f6:	c8 01       	movw	r24, r16
  f8:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
  fc:	8a e2       	ldi	r24, 0x2A	; 42
  fe:	e8 2e       	mov	r14, r24
 100:	81 e0       	ldi	r24, 0x01	; 1
 102:	f8 2e       	mov	r15, r24

    // Run the main scheduling loop, in which the action to run is done repeatedly.
    // In the future, we'll run tasks here; for now, just do things in a simple loop
    while (true)
        {
        // The dummy counter is used to slow down the rate at which stuff is printed
        // on the terminal
        if (++dummy >= 1000000L)
 104:	8b 81       	ldd	r24, Y+3	; 0x03
 106:	9c 81       	ldd	r25, Y+4	; 0x04
 108:	ad 81       	ldd	r26, Y+5	; 0x05
 10a:	be 81       	ldd	r27, Y+6	; 0x06
 10c:	01 96       	adiw	r24, 0x01	; 1
 10e:	a1 1d       	adc	r26, r1
 110:	b1 1d       	adc	r27, r1
 112:	8b 83       	std	Y+3, r24	; 0x03
 114:	9c 83       	std	Y+4, r25	; 0x04
 116:	ad 83       	std	Y+5, r26	; 0x05
 118:	be 83       	std	Y+6, r27	; 0x06
 11a:	8b 81       	ldd	r24, Y+3	; 0x03
 11c:	9c 81       	ldd	r25, Y+4	; 0x04
 11e:	ad 81       	ldd	r26, Y+5	; 0x05
 120:	be 81       	ldd	r27, Y+6	; 0x06
 122:	80 54       	subi	r24, 0x40	; 64
 124:	92 44       	sbci	r25, 0x42	; 66
 126:	af 40       	sbci	r26, 0x0F	; 15
 128:	b0 40       	sbci	r27, 0x00	; 0
 12a:	60 f3       	brcs	.-40     	; 0x104 <main+0x3a>
            {
            dummy = 0;
 12c:	1b 82       	std	Y+3, r1	; 0x03
 12e:	1c 82       	std	Y+4, r1	; 0x04
 130:	1d 82       	std	Y+5, r1	; 0x05
 132:	1e 82       	std	Y+6, r1	; 0x06

            // Cause an analog to digital conversion to take place, and print the
            // result, except there is no result yet
            // conversion = my_adc.read_once (channel_count);

            // Print the results
            the_serial_port << "A/D status:\n\r" << my_adc << endl;
 134:	b7 01       	movw	r22, r14
 136:	c8 01       	movw	r24, r16
 138:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 13c:	b6 01       	movw	r22, r12
 13e:	0e 94 b0 04 	call	0x960	; 0x960 <_ZlsR16base_text_serialR7avr_adc>
 142:	64 e0       	ldi	r22, 0x04	; 4
 144:	70 e0       	ldi	r23, 0x00	; 0
 146:	0e 94 f5 00 	call	0x1ea	; 0x1ea <_ZN16base_text_seriallsE15ser_manipulator>
 14a:	dc cf       	rjmp	.-72     	; 0x104 <main+0x3a>

0000014c <_ZN16base_text_serial7putcharEc>:
            }
        }

    return (0);
    }
 14c:	08 95       	ret

0000014e <_ZN16base_text_serial4putsEPKc>:
 14e:	08 95       	ret

00000150 <_ZN16base_text_serialC2Ev>:
/** This method sets up the base serial port object. It sets the default base for
 *  the conversion of numbers to text. 
 */

base_text_serial::base_text_serial (void)
 150:	fc 01       	movw	r30, r24
 152:	8f e3       	ldi	r24, 0x3F	; 63
 154:	91 e0       	ldi	r25, 0x01	; 1
 156:	91 83       	std	Z+1, r25	; 0x01
 158:	80 83       	st	Z, r24
    {
    base = 10;                              // Numbers are shown as decimal by default
 15a:	8a e0       	ldi	r24, 0x0A	; 10
 15c:	82 83       	std	Z+2, r24	; 0x02
 15e:	08 95       	ret

00000160 <_ZN16base_text_serialC1Ev>:
 160:	fc 01       	movw	r30, r24
 162:	8f e3       	ldi	r24, 0x3F	; 63
 164:	91 e0       	ldi	r25, 0x01	; 1
 166:	91 83       	std	Z+1, r25	; 0x01
 168:	80 83       	st	Z, r24
 16a:	8a e0       	ldi	r24, 0x0A	; 10
 16c:	82 83       	std	Z+2, r24	; 0x02
 16e:	08 95       	ret

00000170 <_ZN16base_text_serial13ready_to_sendEv>:
    }


//-------------------------------------------------------------------------------------
/** This function checks if the serial port transmitter is ready to send data.  It's 
 *  an empty base method, overridden by most serial devices. Some serial devices might
 *  always be ready to send data; those can not bother to override this method. 
 *  @return True if the serial port is ready to send, and false if not
 */

bool base_text_serial::ready_to_send (void)
    {
    return (true);                          // By default the port's always ready
    }
 170:	81 e0       	ldi	r24, 0x01	; 1
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	08 95       	ret

00000176 <_ZN16base_text_serial7getcharEv>:


//-------------------------------------------------------------------------------------
/** This base method just returns zero, because it shouldn't be called. There might be
 *  classes which only send characters and don't ever receive them, and this method
 *  could be left as a placeholder for those classes. 
 *  @return A zero (null character) which means nothing
 */

char base_text_serial::getchar (void)
    {
    return ('\0');                          // Nothing to return, really
    }
 176:	80 e0       	ldi	r24, 0x00	; 0
 178:	90 e0       	ldi	r25, 0x00	; 0
 17a:	08 95       	ret

0000017c <_ZN16base_text_serial14check_for_charEv>:


//-------------------------------------------------------------------------------------
/** This method checks if there is a character in the serial port's receiver buffer.
 *  There isn't, as this base class isn't connected to a buffer; descendent classes
 *  will override this method and check a real buffer for real characters. 
 *  @return False, because no character will ever be available
 */

bool base_text_serial::check_for_char (void)
    {
    return (false);
    }
 17c:	80 e0       	ldi	r24, 0x00	; 0
 17e:	90 e0       	ldi	r25, 0x00	; 0
 180:	08 95       	ret

00000182 <_ZN16base_text_serial12transmit_nowEv>:


//-------------------------------------------------------------------------------------
/** This is a base method for causing immediate transmission of a buffer full of data.
 *  The base method doesn't do anything, because it will be implemented in descendent
 *  classes which have no buffers, send everything immediately by default, and don't 
 *  need to respond to calls for immediate transmission. 
 */

void base_text_serial::transmit_now (void)
 182:	08 95       	ret

00000184 <_ZN16base_text_seriallsEPKc>:
    {
    }


//-------------------------------------------------------------------------------------
/** This method writes the string whose first character is pointed to by the given
 *  character pointer to the serial device. It acts in about the same way as puts(). 
 *  As with puts(), the string must have a null character (ASCII zero) at the end. 
 *  @param string Pointer to the string to be written
 */

base_text_serial& base_text_serial::operator<< (const char* string)
 184:	0f 93       	push	r16
 186:	1f 93       	push	r17
 188:	cf 93       	push	r28
 18a:	df 93       	push	r29
 18c:	8c 01       	movw	r16, r24
 18e:	eb 01       	movw	r28, r22
    {
    while (*string) putchar (*string++);
 190:	68 81       	ld	r22, Y
 192:	66 23       	and	r22, r22
 194:	61 f0       	breq	.+24     	; 0x1ae <_ZN16base_text_seriallsEPKc+0x2a>
 196:	21 96       	adiw	r28, 0x01	; 1
 198:	d8 01       	movw	r26, r16
 19a:	ed 91       	ld	r30, X+
 19c:	fc 91       	ld	r31, X
 19e:	02 80       	ldd	r0, Z+2	; 0x02
 1a0:	f3 81       	ldd	r31, Z+3	; 0x03
 1a2:	e0 2d       	mov	r30, r0
 1a4:	c8 01       	movw	r24, r16
 1a6:	09 95       	icall
 1a8:	68 81       	ld	r22, Y
 1aa:	66 23       	and	r22, r22
 1ac:	a1 f7       	brne	.-24     	; 0x196 <_ZN16base_text_seriallsEPKc+0x12>

    return (*this);
    }
 1ae:	c8 01       	movw	r24, r16
 1b0:	df 91       	pop	r29
 1b2:	cf 91       	pop	r28
 1b4:	1f 91       	pop	r17
 1b6:	0f 91       	pop	r16
 1b8:	08 95       	ret

000001ba <_ZN16base_text_seriallsEb>:


//-------------------------------------------------------------------------------------
/** This method writes a boolean value to the serial port as a character, either "T"
 *  or "F" depending on the value. 
 *  @param value The boolean value to be written
 */

base_text_serial& base_text_serial::operator<< (bool value)
 1ba:	cf 93       	push	r28
 1bc:	df 93       	push	r29
 1be:	ec 01       	movw	r28, r24
    {
    if (value)
 1c0:	66 23       	and	r22, r22
 1c2:	41 f0       	breq	.+16     	; 0x1d4 <_ZN16base_text_seriallsEb+0x1a>
        putchar ('T');
 1c4:	e8 81       	ld	r30, Y
 1c6:	f9 81       	ldd	r31, Y+1	; 0x01
 1c8:	02 80       	ldd	r0, Z+2	; 0x02
 1ca:	f3 81       	ldd	r31, Z+3	; 0x03
 1cc:	e0 2d       	mov	r30, r0
 1ce:	64 e5       	ldi	r22, 0x54	; 84
 1d0:	09 95       	icall
 1d2:	07 c0       	rjmp	.+14     	; 0x1e2 <_ZN16base_text_seriallsEb+0x28>
    else
        putchar ('F');
 1d4:	e8 81       	ld	r30, Y
 1d6:	f9 81       	ldd	r31, Y+1	; 0x01
 1d8:	02 80       	ldd	r0, Z+2	; 0x02
 1da:	f3 81       	ldd	r31, Z+3	; 0x03
 1dc:	e0 2d       	mov	r30, r0
 1de:	66 e4       	ldi	r22, 0x46	; 70
 1e0:	09 95       	icall

    return (*this);;   
    }
 1e2:	ce 01       	movw	r24, r28
 1e4:	df 91       	pop	r29
 1e6:	cf 91       	pop	r28
 1e8:	08 95       	ret

000001ea <_ZN16base_text_seriallsE15ser_manipulator>:


//-------------------------------------------------------------------------------------
/** This method writes a character to the serial port as a text string showing the 
 *  8-bit unsigned number in that character. If one needs to send a character directly
 *  without converting it as a number to a string, then one should use the putchar() 
 *  method instead. 
 *  @param num The 8-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (unsigned char num)
    {
    if (base == 2)
        {
        for (unsigned char bmask = 0x80; bmask != 0; bmask >>= 1)
            {
            if (num & bmask) putchar ('1');
            else             putchar ('0');
            }
        }
    else
        {
        char out_str[9];

        utoa ((unsigned int)num, out_str, base);
        puts (out_str);
        }

    return (*this);
    }


//-------------------------------------------------------------------------------------
/** This method writes a character to the serial port as a text string showing the 
 *  8-bit signed number in that character. If one needs to send a character directly
 *  without converting it as a number to a string, then one should use the putchar() 
 *  method instead. 
 *  @param num The 8-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (char num)
    {
    if (base == 2)
        {
        for (unsigned char bmask = 0x80; bmask != 0; bmask >>= 1)
            {
            if (num & bmask) putchar ('1');
            else             putchar ('0');
            }
        }
    else
        {
        char out_str[10];

        utoa ((unsigned int)num, out_str, base);
        puts (out_str);
        }

    return (*this);
    }


//-------------------------------------------------------------------------------------
/** This method writes an integer to the serial port as a text string showing the 
 *  16-bit unsigned number in that integer. 
 *  @param num The 16-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (unsigned int num)
    {
    if (base == 2)
        {
        for (unsigned int bmask = 0x8000; bmask != 0; bmask >>= 1)
            {
            if (num & bmask) putchar ('1');
            else             putchar ('0');
            }
        }
    else
        {
        char out_str[17];

        utoa (num, out_str, base);
        puts (out_str);
        }

    return (*this);
    }


//-------------------------------------------------------------------------------------
/** This method writes an integer to the serial port as a text string showing the 
 *  16-bit signed number in that integer. 
 *  @param num The 16-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (int num)
    {
    if (base == 2)
        {
        for (unsigned int bmask = 0x8000; bmask != 0; bmask >>= 1)
            {
            if (num & bmask) putchar ('1');
            else             putchar ('0');
            }
        }
    else
        {
        char out_str[17];

        utoa (num, out_str, base);
        puts (out_str);
        }

    return (*this);
    }


//-------------------------------------------------------------------------------------
/** This method writes an unsigned long integer to the serial port as a text string 
 *  showing the 32-bit unsigned number in that long integer. 
 *  @param num The 32-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (unsigned long num)
    {
    if (base == 2)
        {
        union {
            unsigned long whole;
            unsigned char bits[4];
            } parts;
        parts.whole = num;
        *this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
        }
    else
        {
        char out_str[33];
        ultoa ((long)num, out_str, base);
        puts (out_str);
        }

    return (*this);
    }


//-------------------------------------------------------------------------------------
/** This method writes a long integer to the serial port as a text string showing the 
 *  32-bit signed number in that long integer. 
 *  @param num The 32-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (long num)
    {
    if (base == 2)
        {
        union {
            unsigned long whole;
            unsigned char bits[4];
            } parts;
        parts.whole = num;
        *this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
        }
    else
        {
        char out_str[34];
        ltoa ((long)num, out_str, base);
        puts (out_str);
        }

    return (*this);
    }


//-------------------------------------------------------------------------------------
/** This overload allows manipulators to be used to change the base of displayed 
 *  numbers to binary, octal, decimal, or hexadecimal. Also, and endline is provided
 *  with the name "endl" and the code "send_now" causes immediate transmission by
 *  devices which save stuff to be transmitted in buffers. 
 *  @param new_base The new base in which numbers will be displayed
 */

base_text_serial& base_text_serial::operator<< (ser_manipulator new_base)
 1ea:	cf 93       	push	r28
 1ec:	df 93       	push	r29
 1ee:	ec 01       	movw	r28, r24
    {
    switch (new_base)
 1f0:	62 30       	cpi	r22, 0x02	; 2
 1f2:	71 05       	cpc	r23, r1
 1f4:	59 f1       	breq	.+86     	; 0x24c <_ZN16base_text_seriallsE15ser_manipulator+0x62>
 1f6:	63 30       	cpi	r22, 0x03	; 3
 1f8:	71 05       	cpc	r23, r1
 1fa:	4c f0       	brlt	.+18     	; 0x20e <_ZN16base_text_seriallsE15ser_manipulator+0x24>
 1fc:	64 30       	cpi	r22, 0x04	; 4
 1fe:	71 05       	cpc	r23, r1
 200:	e1 f0       	breq	.+56     	; 0x23a <_ZN16base_text_seriallsE15ser_manipulator+0x50>
 202:	64 30       	cpi	r22, 0x04	; 4
 204:	71 05       	cpc	r23, r1
 206:	7c f4       	brge	.+30     	; 0x226 <_ZN16base_text_seriallsE15ser_manipulator+0x3c>
        {
        case (bin):
            base = 2;
            break;
        case (oct):
            base = 8;
            break;
        case (dec):
            base = 10;
            break;
        case (hex):
            base = 16;
 208:	80 e1       	ldi	r24, 0x10	; 16
 20a:	8a 83       	std	Y+2, r24	; 0x02
 20c:	21 c0       	rjmp	.+66     	; 0x250 <_ZN16base_text_seriallsE15ser_manipulator+0x66>
 20e:	61 15       	cp	r22, r1
 210:	71 05       	cpc	r23, r1
 212:	31 f0       	breq	.+12     	; 0x220 <_ZN16base_text_seriallsE15ser_manipulator+0x36>
 214:	61 30       	cpi	r22, 0x01	; 1
 216:	71 05       	cpc	r23, r1
 218:	d9 f4       	brne	.+54     	; 0x250 <_ZN16base_text_seriallsE15ser_manipulator+0x66>
 21a:	88 e0       	ldi	r24, 0x08	; 8
 21c:	8a 83       	std	Y+2, r24	; 0x02
 21e:	18 c0       	rjmp	.+48     	; 0x250 <_ZN16base_text_seriallsE15ser_manipulator+0x66>
 220:	82 e0       	ldi	r24, 0x02	; 2
 222:	8a 83       	std	Y+2, r24	; 0x02
 224:	15 c0       	rjmp	.+42     	; 0x250 <_ZN16base_text_seriallsE15ser_manipulator+0x66>
 226:	65 30       	cpi	r22, 0x05	; 5
 228:	71 05       	cpc	r23, r1
 22a:	91 f4       	brne	.+36     	; 0x250 <_ZN16base_text_seriallsE15ser_manipulator+0x66>
            break;
        case (endl):
            puts ("\r\n");
            break;
        case (send_now):
            transmit_now ();
 22c:	e8 81       	ld	r30, Y
 22e:	f9 81       	ldd	r31, Y+1	; 0x01
 230:	02 84       	ldd	r0, Z+10	; 0x0a
 232:	f3 85       	ldd	r31, Z+11	; 0x0b
 234:	e0 2d       	mov	r30, r0
 236:	09 95       	icall
 238:	0b c0       	rjmp	.+22     	; 0x250 <_ZN16base_text_seriallsE15ser_manipulator+0x66>
 23a:	e8 81       	ld	r30, Y
 23c:	f9 81       	ldd	r31, Y+1	; 0x01
 23e:	04 80       	ldd	r0, Z+4	; 0x04
 240:	f5 81       	ldd	r31, Z+5	; 0x05
 242:	e0 2d       	mov	r30, r0
 244:	68 e3       	ldi	r22, 0x38	; 56
 246:	71 e0       	ldi	r23, 0x01	; 1
 248:	09 95       	icall
 24a:	02 c0       	rjmp	.+4      	; 0x250 <_ZN16base_text_seriallsE15ser_manipulator+0x66>
 24c:	8a e0       	ldi	r24, 0x0A	; 10
 24e:	8a 83       	std	Y+2, r24	; 0x02
            break;
        };

    return (*this);
    }
 250:	ce 01       	movw	r24, r28
 252:	df 91       	pop	r29
 254:	cf 91       	pop	r28
 256:	08 95       	ret

00000258 <_ZN16base_text_seriallsEi>:
 258:	af 92       	push	r10
 25a:	bf 92       	push	r11
 25c:	cf 92       	push	r12
 25e:	df 92       	push	r13
 260:	ef 92       	push	r14
 262:	ff 92       	push	r15
 264:	0f 93       	push	r16
 266:	1f 93       	push	r17
 268:	cf 93       	push	r28
 26a:	df 93       	push	r29
 26c:	cd b7       	in	r28, 0x3d	; 61
 26e:	de b7       	in	r29, 0x3e	; 62
 270:	61 97       	sbiw	r28, 0x11	; 17
 272:	0f b6       	in	r0, 0x3f	; 63
 274:	f8 94       	cli
 276:	de bf       	out	0x3e, r29	; 62
 278:	0f be       	out	0x3f, r0	; 63
 27a:	cd bf       	out	0x3d, r28	; 61
 27c:	7c 01       	movw	r14, r24
 27e:	5b 01       	movw	r10, r22
 280:	fc 01       	movw	r30, r24
 282:	42 81       	ldd	r20, Z+2	; 0x02
 284:	42 30       	cpi	r20, 0x02	; 2
 286:	91 f0       	breq	.+36     	; 0x2ac <_ZN16base_text_seriallsEi+0x54>
 288:	55 27       	eor	r21, r21
 28a:	8e 01       	movw	r16, r28
 28c:	0f 5f       	subi	r16, 0xFF	; 255
 28e:	1f 4f       	sbci	r17, 0xFF	; 255
 290:	b8 01       	movw	r22, r16
 292:	c5 01       	movw	r24, r10
 294:	0e 94 6a 05 	call	0xad4	; 0xad4 <utoa>
 298:	d7 01       	movw	r26, r14
 29a:	ed 91       	ld	r30, X+
 29c:	fc 91       	ld	r31, X
 29e:	04 80       	ldd	r0, Z+4	; 0x04
 2a0:	f5 81       	ldd	r31, Z+5	; 0x05
 2a2:	e0 2d       	mov	r30, r0
 2a4:	b8 01       	movw	r22, r16
 2a6:	c7 01       	movw	r24, r14
 2a8:	09 95       	icall
 2aa:	25 c0       	rjmp	.+74     	; 0x2f6 <_ZN16base_text_seriallsEi+0x9e>
 2ac:	c1 2c       	mov	r12, r1
 2ae:	90 e8       	ldi	r25, 0x80	; 128
 2b0:	d9 2e       	mov	r13, r25
 2b2:	00 e0       	ldi	r16, 0x00	; 0
 2b4:	10 e0       	ldi	r17, 0x00	; 0
 2b6:	10 c0       	rjmp	.+32     	; 0x2d8 <_ZN16base_text_seriallsEi+0x80>
 2b8:	d7 01       	movw	r26, r14
 2ba:	ed 91       	ld	r30, X+
 2bc:	fc 91       	ld	r31, X
 2be:	02 80       	ldd	r0, Z+2	; 0x02
 2c0:	f3 81       	ldd	r31, Z+3	; 0x03
 2c2:	e0 2d       	mov	r30, r0
 2c4:	61 e3       	ldi	r22, 0x31	; 49
 2c6:	c7 01       	movw	r24, r14
 2c8:	09 95       	icall
 2ca:	d6 94       	lsr	r13
 2cc:	c7 94       	ror	r12
 2ce:	0f 5f       	subi	r16, 0xFF	; 255
 2d0:	1f 4f       	sbci	r17, 0xFF	; 255
 2d2:	00 31       	cpi	r16, 0x10	; 16
 2d4:	11 05       	cpc	r17, r1
 2d6:	79 f0       	breq	.+30     	; 0x2f6 <_ZN16base_text_seriallsEi+0x9e>
 2d8:	c6 01       	movw	r24, r12
 2da:	8a 21       	and	r24, r10
 2dc:	9b 21       	and	r25, r11
 2de:	89 2b       	or	r24, r25
 2e0:	59 f7       	brne	.-42     	; 0x2b8 <_ZN16base_text_seriallsEi+0x60>
 2e2:	d7 01       	movw	r26, r14
 2e4:	ed 91       	ld	r30, X+
 2e6:	fc 91       	ld	r31, X
 2e8:	02 80       	ldd	r0, Z+2	; 0x02
 2ea:	f3 81       	ldd	r31, Z+3	; 0x03
 2ec:	e0 2d       	mov	r30, r0
 2ee:	60 e3       	ldi	r22, 0x30	; 48
 2f0:	c7 01       	movw	r24, r14
 2f2:	09 95       	icall
 2f4:	ea cf       	rjmp	.-44     	; 0x2ca <_ZN16base_text_seriallsEi+0x72>
 2f6:	c7 01       	movw	r24, r14
 2f8:	61 96       	adiw	r28, 0x11	; 17
 2fa:	0f b6       	in	r0, 0x3f	; 63
 2fc:	f8 94       	cli
 2fe:	de bf       	out	0x3e, r29	; 62
 300:	0f be       	out	0x3f, r0	; 63
 302:	cd bf       	out	0x3d, r28	; 61
 304:	df 91       	pop	r29
 306:	cf 91       	pop	r28
 308:	1f 91       	pop	r17
 30a:	0f 91       	pop	r16
 30c:	ff 90       	pop	r15
 30e:	ef 90       	pop	r14
 310:	df 90       	pop	r13
 312:	cf 90       	pop	r12
 314:	bf 90       	pop	r11
 316:	af 90       	pop	r10
 318:	08 95       	ret

0000031a <_ZN16base_text_seriallsEj>:
 31a:	af 92       	push	r10
 31c:	bf 92       	push	r11
 31e:	cf 92       	push	r12
 320:	df 92       	push	r13
 322:	ef 92       	push	r14
 324:	ff 92       	push	r15
 326:	0f 93       	push	r16
 328:	1f 93       	push	r17
 32a:	cf 93       	push	r28
 32c:	df 93       	push	r29
 32e:	cd b7       	in	r28, 0x3d	; 61
 330:	de b7       	in	r29, 0x3e	; 62
 332:	61 97       	sbiw	r28, 0x11	; 17
 334:	0f b6       	in	r0, 0x3f	; 63
 336:	f8 94       	cli
 338:	de bf       	out	0x3e, r29	; 62
 33a:	0f be       	out	0x3f, r0	; 63
 33c:	cd bf       	out	0x3d, r28	; 61
 33e:	7c 01       	movw	r14, r24
 340:	5b 01       	movw	r10, r22
 342:	fc 01       	movw	r30, r24
 344:	42 81       	ldd	r20, Z+2	; 0x02
 346:	42 30       	cpi	r20, 0x02	; 2
 348:	91 f0       	breq	.+36     	; 0x36e <_ZN16base_text_seriallsEj+0x54>
 34a:	55 27       	eor	r21, r21
 34c:	8e 01       	movw	r16, r28
 34e:	0f 5f       	subi	r16, 0xFF	; 255
 350:	1f 4f       	sbci	r17, 0xFF	; 255
 352:	b8 01       	movw	r22, r16
 354:	c5 01       	movw	r24, r10
 356:	0e 94 6a 05 	call	0xad4	; 0xad4 <utoa>
 35a:	d7 01       	movw	r26, r14
 35c:	ed 91       	ld	r30, X+
 35e:	fc 91       	ld	r31, X
 360:	04 80       	ldd	r0, Z+4	; 0x04
 362:	f5 81       	ldd	r31, Z+5	; 0x05
 364:	e0 2d       	mov	r30, r0
 366:	b8 01       	movw	r22, r16
 368:	c7 01       	movw	r24, r14
 36a:	09 95       	icall
 36c:	25 c0       	rjmp	.+74     	; 0x3b8 <_ZN16base_text_seriallsEj+0x9e>
 36e:	c1 2c       	mov	r12, r1
 370:	30 e8       	ldi	r19, 0x80	; 128
 372:	d3 2e       	mov	r13, r19
 374:	00 e0       	ldi	r16, 0x00	; 0
 376:	10 e0       	ldi	r17, 0x00	; 0
 378:	10 c0       	rjmp	.+32     	; 0x39a <_ZN16base_text_seriallsEj+0x80>
 37a:	d7 01       	movw	r26, r14
 37c:	ed 91       	ld	r30, X+
 37e:	fc 91       	ld	r31, X
 380:	02 80       	ldd	r0, Z+2	; 0x02
 382:	f3 81       	ldd	r31, Z+3	; 0x03
 384:	e0 2d       	mov	r30, r0
 386:	61 e3       	ldi	r22, 0x31	; 49
 388:	c7 01       	movw	r24, r14
 38a:	09 95       	icall
 38c:	d6 94       	lsr	r13
 38e:	c7 94       	ror	r12
 390:	0f 5f       	subi	r16, 0xFF	; 255
 392:	1f 4f       	sbci	r17, 0xFF	; 255
 394:	00 31       	cpi	r16, 0x10	; 16
 396:	11 05       	cpc	r17, r1
 398:	79 f0       	breq	.+30     	; 0x3b8 <_ZN16base_text_seriallsEj+0x9e>
 39a:	c6 01       	movw	r24, r12
 39c:	8a 21       	and	r24, r10
 39e:	9b 21       	and	r25, r11
 3a0:	89 2b       	or	r24, r25
 3a2:	59 f7       	brne	.-42     	; 0x37a <_ZN16base_text_seriallsEj+0x60>
 3a4:	d7 01       	movw	r26, r14
 3a6:	ed 91       	ld	r30, X+
 3a8:	fc 91       	ld	r31, X
 3aa:	02 80       	ldd	r0, Z+2	; 0x02
 3ac:	f3 81       	ldd	r31, Z+3	; 0x03
 3ae:	e0 2d       	mov	r30, r0
 3b0:	60 e3       	ldi	r22, 0x30	; 48
 3b2:	c7 01       	movw	r24, r14
 3b4:	09 95       	icall
 3b6:	ea cf       	rjmp	.-44     	; 0x38c <_ZN16base_text_seriallsEj+0x72>
 3b8:	c7 01       	movw	r24, r14
 3ba:	61 96       	adiw	r28, 0x11	; 17
 3bc:	0f b6       	in	r0, 0x3f	; 63
 3be:	f8 94       	cli
 3c0:	de bf       	out	0x3e, r29	; 62
 3c2:	0f be       	out	0x3f, r0	; 63
 3c4:	cd bf       	out	0x3d, r28	; 61
 3c6:	df 91       	pop	r29
 3c8:	cf 91       	pop	r28
 3ca:	1f 91       	pop	r17
 3cc:	0f 91       	pop	r16
 3ce:	ff 90       	pop	r15
 3d0:	ef 90       	pop	r14
 3d2:	df 90       	pop	r13
 3d4:	cf 90       	pop	r12
 3d6:	bf 90       	pop	r11
 3d8:	af 90       	pop	r10
 3da:	08 95       	ret

000003dc <_ZN16base_text_seriallsEc>:
 3dc:	af 92       	push	r10
 3de:	bf 92       	push	r11
 3e0:	df 92       	push	r13
 3e2:	ef 92       	push	r14
 3e4:	ff 92       	push	r15
 3e6:	0f 93       	push	r16
 3e8:	1f 93       	push	r17
 3ea:	cf 93       	push	r28
 3ec:	df 93       	push	r29
 3ee:	cd b7       	in	r28, 0x3d	; 61
 3f0:	de b7       	in	r29, 0x3e	; 62
 3f2:	2a 97       	sbiw	r28, 0x0a	; 10
 3f4:	0f b6       	in	r0, 0x3f	; 63
 3f6:	f8 94       	cli
 3f8:	de bf       	out	0x3e, r29	; 62
 3fa:	0f be       	out	0x3f, r0	; 63
 3fc:	cd bf       	out	0x3d, r28	; 61
 3fe:	7c 01       	movw	r14, r24
 400:	86 2f       	mov	r24, r22
 402:	f7 01       	movw	r30, r14
 404:	42 81       	ldd	r20, Z+2	; 0x02
 406:	42 30       	cpi	r20, 0x02	; 2
 408:	a1 f0       	breq	.+40     	; 0x432 <_ZN16base_text_seriallsEc+0x56>
 40a:	55 27       	eor	r21, r21
 40c:	8e 01       	movw	r16, r28
 40e:	0f 5f       	subi	r16, 0xFF	; 255
 410:	1f 4f       	sbci	r17, 0xFF	; 255
 412:	b8 01       	movw	r22, r16
 414:	99 27       	eor	r25, r25
 416:	87 fd       	sbrc	r24, 7
 418:	90 95       	com	r25
 41a:	0e 94 6a 05 	call	0xad4	; 0xad4 <utoa>
 41e:	d7 01       	movw	r26, r14
 420:	ed 91       	ld	r30, X+
 422:	fc 91       	ld	r31, X
 424:	04 80       	ldd	r0, Z+4	; 0x04
 426:	f5 81       	ldd	r31, Z+5	; 0x05
 428:	e0 2d       	mov	r30, r0
 42a:	b8 01       	movw	r22, r16
 42c:	c7 01       	movw	r24, r14
 42e:	09 95       	icall
 430:	28 c0       	rjmp	.+80     	; 0x482 <_ZN16base_text_seriallsEc+0xa6>
 432:	a6 2e       	mov	r10, r22
 434:	bb 24       	eor	r11, r11
 436:	a7 fc       	sbrc	r10, 7
 438:	b0 94       	com	r11
 43a:	40 e8       	ldi	r20, 0x80	; 128
 43c:	d4 2e       	mov	r13, r20
 43e:	00 e0       	ldi	r16, 0x00	; 0
 440:	10 e0       	ldi	r17, 0x00	; 0
 442:	0f c0       	rjmp	.+30     	; 0x462 <_ZN16base_text_seriallsEc+0x86>
 444:	d7 01       	movw	r26, r14
 446:	ed 91       	ld	r30, X+
 448:	fc 91       	ld	r31, X
 44a:	02 80       	ldd	r0, Z+2	; 0x02
 44c:	f3 81       	ldd	r31, Z+3	; 0x03
 44e:	e0 2d       	mov	r30, r0
 450:	61 e3       	ldi	r22, 0x31	; 49
 452:	c7 01       	movw	r24, r14
 454:	09 95       	icall
 456:	d6 94       	lsr	r13
 458:	0f 5f       	subi	r16, 0xFF	; 255
 45a:	1f 4f       	sbci	r17, 0xFF	; 255
 45c:	08 30       	cpi	r16, 0x08	; 8
 45e:	11 05       	cpc	r17, r1
 460:	81 f0       	breq	.+32     	; 0x482 <_ZN16base_text_seriallsEc+0xa6>
 462:	8d 2d       	mov	r24, r13
 464:	99 27       	eor	r25, r25
 466:	8a 21       	and	r24, r10
 468:	9b 21       	and	r25, r11
 46a:	89 2b       	or	r24, r25
 46c:	59 f7       	brne	.-42     	; 0x444 <_ZN16base_text_seriallsEc+0x68>
 46e:	d7 01       	movw	r26, r14
 470:	ed 91       	ld	r30, X+
 472:	fc 91       	ld	r31, X
 474:	02 80       	ldd	r0, Z+2	; 0x02
 476:	f3 81       	ldd	r31, Z+3	; 0x03
 478:	e0 2d       	mov	r30, r0
 47a:	60 e3       	ldi	r22, 0x30	; 48
 47c:	c7 01       	movw	r24, r14
 47e:	09 95       	icall
 480:	ea cf       	rjmp	.-44     	; 0x456 <_ZN16base_text_seriallsEc+0x7a>
 482:	c7 01       	movw	r24, r14
 484:	2a 96       	adiw	r28, 0x0a	; 10
 486:	0f b6       	in	r0, 0x3f	; 63
 488:	f8 94       	cli
 48a:	de bf       	out	0x3e, r29	; 62
 48c:	0f be       	out	0x3f, r0	; 63
 48e:	cd bf       	out	0x3d, r28	; 61
 490:	df 91       	pop	r29
 492:	cf 91       	pop	r28
 494:	1f 91       	pop	r17
 496:	0f 91       	pop	r16
 498:	ff 90       	pop	r15
 49a:	ef 90       	pop	r14
 49c:	df 90       	pop	r13
 49e:	bf 90       	pop	r11
 4a0:	af 90       	pop	r10
 4a2:	08 95       	ret

000004a4 <_ZN16base_text_seriallsEh>:
 4a4:	af 92       	push	r10
 4a6:	bf 92       	push	r11
 4a8:	df 92       	push	r13
 4aa:	ef 92       	push	r14
 4ac:	ff 92       	push	r15
 4ae:	0f 93       	push	r16
 4b0:	1f 93       	push	r17
 4b2:	cf 93       	push	r28
 4b4:	df 93       	push	r29
 4b6:	cd b7       	in	r28, 0x3d	; 61
 4b8:	de b7       	in	r29, 0x3e	; 62
 4ba:	29 97       	sbiw	r28, 0x09	; 9
 4bc:	0f b6       	in	r0, 0x3f	; 63
 4be:	f8 94       	cli
 4c0:	de bf       	out	0x3e, r29	; 62
 4c2:	0f be       	out	0x3f, r0	; 63
 4c4:	cd bf       	out	0x3d, r28	; 61
 4c6:	7c 01       	movw	r14, r24
 4c8:	86 2f       	mov	r24, r22
 4ca:	f7 01       	movw	r30, r14
 4cc:	42 81       	ldd	r20, Z+2	; 0x02
 4ce:	42 30       	cpi	r20, 0x02	; 2
 4d0:	91 f0       	breq	.+36     	; 0x4f6 <_ZN16base_text_seriallsEh+0x52>
 4d2:	55 27       	eor	r21, r21
 4d4:	8e 01       	movw	r16, r28
 4d6:	0f 5f       	subi	r16, 0xFF	; 255
 4d8:	1f 4f       	sbci	r17, 0xFF	; 255
 4da:	b8 01       	movw	r22, r16
 4dc:	99 27       	eor	r25, r25
 4de:	0e 94 6a 05 	call	0xad4	; 0xad4 <utoa>
 4e2:	d7 01       	movw	r26, r14
 4e4:	ed 91       	ld	r30, X+
 4e6:	fc 91       	ld	r31, X
 4e8:	04 80       	ldd	r0, Z+4	; 0x04
 4ea:	f5 81       	ldd	r31, Z+5	; 0x05
 4ec:	e0 2d       	mov	r30, r0
 4ee:	b8 01       	movw	r22, r16
 4f0:	c7 01       	movw	r24, r14
 4f2:	09 95       	icall
 4f4:	26 c0       	rjmp	.+76     	; 0x542 <_ZN16base_text_seriallsEh+0x9e>
 4f6:	a6 2e       	mov	r10, r22
 4f8:	bb 24       	eor	r11, r11
 4fa:	50 e8       	ldi	r21, 0x80	; 128
 4fc:	d5 2e       	mov	r13, r21
 4fe:	00 e0       	ldi	r16, 0x00	; 0
 500:	10 e0       	ldi	r17, 0x00	; 0
 502:	0f c0       	rjmp	.+30     	; 0x522 <_ZN16base_text_seriallsEh+0x7e>
 504:	d7 01       	movw	r26, r14
 506:	ed 91       	ld	r30, X+
 508:	fc 91       	ld	r31, X
 50a:	02 80       	ldd	r0, Z+2	; 0x02
 50c:	f3 81       	ldd	r31, Z+3	; 0x03
 50e:	e0 2d       	mov	r30, r0
 510:	61 e3       	ldi	r22, 0x31	; 49
 512:	c7 01       	movw	r24, r14
 514:	09 95       	icall
 516:	d6 94       	lsr	r13
 518:	0f 5f       	subi	r16, 0xFF	; 255
 51a:	1f 4f       	sbci	r17, 0xFF	; 255
 51c:	08 30       	cpi	r16, 0x08	; 8
 51e:	11 05       	cpc	r17, r1
 520:	81 f0       	breq	.+32     	; 0x542 <_ZN16base_text_seriallsEh+0x9e>
 522:	8d 2d       	mov	r24, r13
 524:	99 27       	eor	r25, r25
 526:	8a 21       	and	r24, r10
 528:	9b 21       	and	r25, r11
 52a:	89 2b       	or	r24, r25
 52c:	59 f7       	brne	.-42     	; 0x504 <_ZN16base_text_seriallsEh+0x60>
 52e:	d7 01       	movw	r26, r14
 530:	ed 91       	ld	r30, X+
 532:	fc 91       	ld	r31, X
 534:	02 80       	ldd	r0, Z+2	; 0x02
 536:	f3 81       	ldd	r31, Z+3	; 0x03
 538:	e0 2d       	mov	r30, r0
 53a:	60 e3       	ldi	r22, 0x30	; 48
 53c:	c7 01       	movw	r24, r14
 53e:	09 95       	icall
 540:	ea cf       	rjmp	.-44     	; 0x516 <_ZN16base_text_seriallsEh+0x72>
 542:	c7 01       	movw	r24, r14
 544:	29 96       	adiw	r28, 0x09	; 9
 546:	0f b6       	in	r0, 0x3f	; 63
 548:	f8 94       	cli
 54a:	de bf       	out	0x3e, r29	; 62
 54c:	0f be       	out	0x3f, r0	; 63
 54e:	cd bf       	out	0x3d, r28	; 61
 550:	df 91       	pop	r29
 552:	cf 91       	pop	r28
 554:	1f 91       	pop	r17
 556:	0f 91       	pop	r16
 558:	ff 90       	pop	r15
 55a:	ef 90       	pop	r14
 55c:	df 90       	pop	r13
 55e:	bf 90       	pop	r11
 560:	af 90       	pop	r10
 562:	08 95       	ret

00000564 <_ZN16base_text_seriallsEl>:
 564:	af 92       	push	r10
 566:	bf 92       	push	r11
 568:	cf 92       	push	r12
 56a:	df 92       	push	r13
 56c:	ef 92       	push	r14
 56e:	ff 92       	push	r15
 570:	0f 93       	push	r16
 572:	1f 93       	push	r17
 574:	cf 93       	push	r28
 576:	df 93       	push	r29
 578:	cd b7       	in	r28, 0x3d	; 61
 57a:	de b7       	in	r29, 0x3e	; 62
 57c:	a2 97       	sbiw	r28, 0x22	; 34
 57e:	0f b6       	in	r0, 0x3f	; 63
 580:	f8 94       	cli
 582:	de bf       	out	0x3e, r29	; 62
 584:	0f be       	out	0x3f, r0	; 63
 586:	cd bf       	out	0x3d, r28	; 61
 588:	5c 01       	movw	r10, r24
 58a:	6a 01       	movw	r12, r20
 58c:	7b 01       	movw	r14, r22
 58e:	fc 01       	movw	r30, r24
 590:	22 81       	ldd	r18, Z+2	; 0x02
 592:	22 30       	cpi	r18, 0x02	; 2
 594:	99 f0       	breq	.+38     	; 0x5bc <_ZN16base_text_seriallsEl+0x58>
 596:	33 27       	eor	r19, r19
 598:	8e 01       	movw	r16, r28
 59a:	0f 5f       	subi	r16, 0xFF	; 255
 59c:	1f 4f       	sbci	r17, 0xFF	; 255
 59e:	a8 01       	movw	r20, r16
 5a0:	c7 01       	movw	r24, r14
 5a2:	b6 01       	movw	r22, r12
 5a4:	0e 94 11 05 	call	0xa22	; 0xa22 <ltoa>
 5a8:	d5 01       	movw	r26, r10
 5aa:	ed 91       	ld	r30, X+
 5ac:	fc 91       	ld	r31, X
 5ae:	04 80       	ldd	r0, Z+4	; 0x04
 5b0:	f5 81       	ldd	r31, Z+5	; 0x05
 5b2:	e0 2d       	mov	r30, r0
 5b4:	b8 01       	movw	r22, r16
 5b6:	c5 01       	movw	r24, r10
 5b8:	09 95       	icall
 5ba:	0c c0       	rjmp	.+24     	; 0x5d4 <_ZN16base_text_seriallsEl+0x70>
 5bc:	6f 2d       	mov	r22, r15
 5be:	0e 94 52 02 	call	0x4a4	; 0x4a4 <_ZN16base_text_seriallsEh>
 5c2:	6e 2d       	mov	r22, r14
 5c4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <_ZN16base_text_seriallsEh>
 5c8:	6d 2d       	mov	r22, r13
 5ca:	0e 94 52 02 	call	0x4a4	; 0x4a4 <_ZN16base_text_seriallsEh>
 5ce:	6c 2d       	mov	r22, r12
 5d0:	0e 94 52 02 	call	0x4a4	; 0x4a4 <_ZN16base_text_seriallsEh>
 5d4:	c5 01       	movw	r24, r10
 5d6:	a2 96       	adiw	r28, 0x22	; 34
 5d8:	0f b6       	in	r0, 0x3f	; 63
 5da:	f8 94       	cli
 5dc:	de bf       	out	0x3e, r29	; 62
 5de:	0f be       	out	0x3f, r0	; 63
 5e0:	cd bf       	out	0x3d, r28	; 61
 5e2:	df 91       	pop	r29
 5e4:	cf 91       	pop	r28
 5e6:	1f 91       	pop	r17
 5e8:	0f 91       	pop	r16
 5ea:	ff 90       	pop	r15
 5ec:	ef 90       	pop	r14
 5ee:	df 90       	pop	r13
 5f0:	cf 90       	pop	r12
 5f2:	bf 90       	pop	r11
 5f4:	af 90       	pop	r10
 5f6:	08 95       	ret

000005f8 <_ZN16base_text_seriallsEm>:
 5f8:	af 92       	push	r10
 5fa:	bf 92       	push	r11
 5fc:	cf 92       	push	r12
 5fe:	df 92       	push	r13
 600:	ef 92       	push	r14
 602:	ff 92       	push	r15
 604:	0f 93       	push	r16
 606:	1f 93       	push	r17
 608:	cf 93       	push	r28
 60a:	df 93       	push	r29
 60c:	cd b7       	in	r28, 0x3d	; 61
 60e:	de b7       	in	r29, 0x3e	; 62
 610:	a1 97       	sbiw	r28, 0x21	; 33
 612:	0f b6       	in	r0, 0x3f	; 63
 614:	f8 94       	cli
 616:	de bf       	out	0x3e, r29	; 62
 618:	0f be       	out	0x3f, r0	; 63
 61a:	cd bf       	out	0x3d, r28	; 61
 61c:	5c 01       	movw	r10, r24
 61e:	6a 01       	movw	r12, r20
 620:	7b 01       	movw	r14, r22
 622:	fc 01       	movw	r30, r24
 624:	22 81       	ldd	r18, Z+2	; 0x02
 626:	22 30       	cpi	r18, 0x02	; 2
 628:	99 f0       	breq	.+38     	; 0x650 <_ZN16base_text_seriallsEm+0x58>
 62a:	33 27       	eor	r19, r19
 62c:	8e 01       	movw	r16, r28
 62e:	0f 5f       	subi	r16, 0xFF	; 255
 630:	1f 4f       	sbci	r17, 0xFF	; 255
 632:	a8 01       	movw	r20, r16
 634:	c7 01       	movw	r24, r14
 636:	b6 01       	movw	r22, r12
 638:	0e 94 45 05 	call	0xa8a	; 0xa8a <ultoa>
 63c:	d5 01       	movw	r26, r10
 63e:	ed 91       	ld	r30, X+
 640:	fc 91       	ld	r31, X
 642:	04 80       	ldd	r0, Z+4	; 0x04
 644:	f5 81       	ldd	r31, Z+5	; 0x05
 646:	e0 2d       	mov	r30, r0
 648:	b8 01       	movw	r22, r16
 64a:	c5 01       	movw	r24, r10
 64c:	09 95       	icall
 64e:	0c c0       	rjmp	.+24     	; 0x668 <_ZN16base_text_seriallsEm+0x70>
 650:	6f 2d       	mov	r22, r15
 652:	0e 94 52 02 	call	0x4a4	; 0x4a4 <_ZN16base_text_seriallsEh>
 656:	6e 2d       	mov	r22, r14
 658:	0e 94 52 02 	call	0x4a4	; 0x4a4 <_ZN16base_text_seriallsEh>
 65c:	6d 2d       	mov	r22, r13
 65e:	0e 94 52 02 	call	0x4a4	; 0x4a4 <_ZN16base_text_seriallsEh>
 662:	6c 2d       	mov	r22, r12
 664:	0e 94 52 02 	call	0x4a4	; 0x4a4 <_ZN16base_text_seriallsEh>
 668:	c5 01       	movw	r24, r10
 66a:	a1 96       	adiw	r28, 0x21	; 33
 66c:	0f b6       	in	r0, 0x3f	; 63
 66e:	f8 94       	cli
 670:	de bf       	out	0x3e, r29	; 62
 672:	0f be       	out	0x3f, r0	; 63
 674:	cd bf       	out	0x3d, r28	; 61
 676:	df 91       	pop	r29
 678:	cf 91       	pop	r28
 67a:	1f 91       	pop	r17
 67c:	0f 91       	pop	r16
 67e:	ff 90       	pop	r15
 680:	ef 90       	pop	r14
 682:	df 90       	pop	r13
 684:	cf 90       	pop	r12
 686:	bf 90       	pop	r11
 688:	af 90       	pop	r10
 68a:	08 95       	ret

0000068c <_ZN5rs23213ready_to_sendEv>:
 *  tests whether transmitter buffer is empty. 
 *  @return True if the serial port is ready to send, and false if not
 */

bool rs232::ready_to_send (void)
 68c:	cf 93       	push	r28
 68e:	df 93       	push	r29
    {
    // If transmitter buffer is full, we're not ready to send
    if (*p_USR & UDRE_MASK)
 690:	ec 01       	movw	r28, r24
 692:	ed 81       	ldd	r30, Y+5	; 0x05
 694:	fe 81       	ldd	r31, Y+6	; 0x06
 696:	80 81       	ld	r24, Z
 698:	99 27       	eor	r25, r25
 69a:	96 95       	lsr	r25
 69c:	87 95       	ror	r24
 69e:	92 95       	swap	r25
 6a0:	82 95       	swap	r24
 6a2:	8f 70       	andi	r24, 0x0F	; 15
 6a4:	89 27       	eor	r24, r25
 6a6:	9f 70       	andi	r25, 0x0F	; 15
 6a8:	89 27       	eor	r24, r25
        return (true);

    return (false);
    }
 6aa:	81 70       	andi	r24, 0x01	; 1
 6ac:	90 70       	andi	r25, 0x00	; 0
 6ae:	df 91       	pop	r29
 6b0:	cf 91       	pop	r28
 6b2:	08 95       	ret

000006b4 <_ZN5rs2327putcharEc>:


//-------------------------------------------------------------------------------------
/** This method sends one character to the serial port.  It waits until the port is
 *  ready, so it can hold up the system for a while.  It times out if it waits too 
 *  long to send the character; you can check the return value to see if the character
 *  was successfully sent, or just cross your fingers and ignore the return value.
 *  Note 1:  It's possible that at slower baud rates and/or higher processor speeds, 
 *  this routine might time out even when the port is working fine.  A solution would
 *  be to change the count variable to an integer and use a larger starting number. 
 *  Note 2:  Fixed!  The count is now an integer and it works at lower baud rates.
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
 6b4:	cf 93       	push	r28
 6b6:	df 93       	push	r29
 6b8:	dc 01       	movw	r26, r24
    {
    unsigned int count = 0;                 // Timeout counter

    // Now wait for the serial port transmitter buffer to be empty     
    for (count = 0; ((*p_USR & UDRE_MASK) == 0); count++)
 6ba:	ec 01       	movw	r28, r24
 6bc:	ed 81       	ldd	r30, Y+5	; 0x05
 6be:	fe 81       	ldd	r31, Y+6	; 0x06
 6c0:	80 81       	ld	r24, Z
 6c2:	85 fd       	sbrc	r24, 5
 6c4:	0c c0       	rjmp	.+24     	; 0x6de <_ZN5rs2327putcharEc+0x2a>
 6c6:	20 e0       	ldi	r18, 0x00	; 0
 6c8:	30 e0       	ldi	r19, 0x00	; 0
 6ca:	06 c0       	rjmp	.+12     	; 0x6d8 <_ZN5rs2327putcharEc+0x24>
 6cc:	2f 5f       	subi	r18, 0xFF	; 255
 6ce:	3f 4f       	sbci	r19, 0xFF	; 255
        {
        if (count > UART_TX_TOUT)
 6d0:	8e e4       	ldi	r24, 0x4E	; 78
 6d2:	21 32       	cpi	r18, 0x21	; 33
 6d4:	38 07       	cpc	r19, r24
 6d6:	51 f0       	breq	.+20     	; 0x6ec <_ZN5rs2327putcharEc+0x38>
 6d8:	80 81       	ld	r24, Z
 6da:	85 ff       	sbrs	r24, 5
 6dc:	f7 cf       	rjmp	.-18     	; 0x6cc <_ZN5rs2327putcharEc+0x18>
            return (false);
        }

    // The CTS line is 0 and the transmitter buffer is empty, so send the character
    *p_UDR = chout;
 6de:	ed 01       	movw	r28, r26
 6e0:	eb 81       	ldd	r30, Y+3	; 0x03
 6e2:	fc 81       	ldd	r31, Y+4	; 0x04
 6e4:	60 83       	st	Z, r22
 6e6:	81 e0       	ldi	r24, 0x01	; 1
 6e8:	90 e0       	ldi	r25, 0x00	; 0
 6ea:	02 c0       	rjmp	.+4      	; 0x6f0 <_ZN5rs2327putcharEc+0x3c>
 6ec:	80 e0       	ldi	r24, 0x00	; 0
 6ee:	90 e0       	ldi	r25, 0x00	; 0
 6f0:	df 91       	pop	r29
 6f2:	cf 91       	pop	r28
 6f4:	08 95       	ret

000006f6 <_ZN5rs2324putsEPKc>:
    return (true);
    }


//-------------------------------------------------------------------------------------
/** This method writes all the characters in a string until it gets to the '\\0' at 
 *  the end. Warning: This function blocks until it's finished. 
 *  @param str The string to be written 
 */

void rs232::puts (char const* str)
 6f6:	0f 93       	push	r16
 6f8:	1f 93       	push	r17
 6fa:	cf 93       	push	r28
 6fc:	df 93       	push	r29
 6fe:	8c 01       	movw	r16, r24
 700:	eb 01       	movw	r28, r22
    {
    while (*str) putchar (*str++);
 702:	68 81       	ld	r22, Y
 704:	66 23       	and	r22, r22
 706:	61 f0       	breq	.+24     	; 0x720 <_ZN5rs2324putsEPKc+0x2a>
 708:	21 96       	adiw	r28, 0x01	; 1
 70a:	d8 01       	movw	r26, r16
 70c:	ed 91       	ld	r30, X+
 70e:	fc 91       	ld	r31, X
 710:	02 80       	ldd	r0, Z+2	; 0x02
 712:	f3 81       	ldd	r31, Z+3	; 0x03
 714:	e0 2d       	mov	r30, r0
 716:	c8 01       	movw	r24, r16
 718:	09 95       	icall
 71a:	68 81       	ld	r22, Y
 71c:	66 23       	and	r22, r22
 71e:	a1 f7       	brne	.-24     	; 0x708 <_ZN5rs2324putsEPKc+0x12>
 720:	df 91       	pop	r29
 722:	cf 91       	pop	r28
 724:	1f 91       	pop	r17
 726:	0f 91       	pop	r16
 728:	08 95       	ret

0000072a <_ZN5rs2327getcharEv>:
    }


//-------------------------------------------------------------------------------------
/** This method gets one character from the serial port, if one is there.  If not, it
 *  waits until there is a character available.  This can sometimes take a long time
 *  (even forever), so use this function carefully.  One should almost always use
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

char rs232::getchar (void)
 72a:	cf 93       	push	r28
 72c:	df 93       	push	r29
 72e:	dc 01       	movw	r26, r24
 730:	ec 01       	movw	r28, r24
 732:	ed 81       	ldd	r30, Y+5	; 0x05
 734:	fe 81       	ldd	r31, Y+6	; 0x06
    {
    //  Wait until there's something in the receiver buffer
    while ((*p_USR & RXC_MASK) == 0);
 736:	80 81       	ld	r24, Z
 738:	87 ff       	sbrs	r24, 7
 73a:	fd cf       	rjmp	.-6      	; 0x736 <_ZN5rs2327getcharEv+0xc>

    //  Return the character retreived from the buffer
    return (*p_UDR);
 73c:	ed 01       	movw	r28, r26
 73e:	eb 81       	ldd	r30, Y+3	; 0x03
 740:	fc 81       	ldd	r31, Y+4	; 0x04
 742:	80 81       	ld	r24, Z
    }
 744:	99 27       	eor	r25, r25
 746:	87 fd       	sbrc	r24, 7
 748:	90 95       	com	r25
 74a:	df 91       	pop	r29
 74c:	cf 91       	pop	r28
 74e:	08 95       	ret

00000750 <_ZN5rs23214check_for_charEv>:


//-------------------------------------------------------------------------------------
/** This function checks if there is a character in the serial port's receiver buffer.
 *  It returns 1 if there's a character available, and 0 if not. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
 750:	cf 93       	push	r28
 752:	df 93       	push	r29
    {
    if (*p_USR & RXC_MASK)
 754:	ec 01       	movw	r28, r24
 756:	ed 81       	ldd	r30, Y+5	; 0x05
 758:	fe 81       	ldd	r31, Y+6	; 0x06
 75a:	80 81       	ld	r24, Z
 75c:	99 27       	eor	r25, r25
 75e:	87 fd       	sbrc	r24, 7
 760:	90 95       	com	r25
        return (true);
    else
        return (false);
    }
 762:	88 27       	eor	r24, r24
 764:	99 0f       	add	r25, r25
 766:	88 1f       	adc	r24, r24
 768:	99 27       	eor	r25, r25
 76a:	df 91       	pop	r29
 76c:	cf 91       	pop	r28
 76e:	08 95       	ret

00000770 <_ZN5rs232C1Ehh>:
 770:	0f 93       	push	r16
 772:	1f 93       	push	r17
 774:	cf 93       	push	r28
 776:	df 93       	push	r29
 778:	ec 01       	movw	r28, r24
 77a:	06 2f       	mov	r16, r22
 77c:	14 2f       	mov	r17, r20
 77e:	0e 94 a8 00 	call	0x150	; 0x150 <_ZN16base_text_serialC2Ev>
 782:	8f e4       	ldi	r24, 0x4F	; 79
 784:	91 e0       	ldi	r25, 0x01	; 1
 786:	99 83       	std	Y+1, r25	; 0x01
 788:	88 83       	st	Y, r24
 78a:	11 23       	and	r17, r17
 78c:	a9 f4       	brne	.+42     	; 0x7b8 <_ZN5rs232C1Ehh+0x48>
 78e:	8c e2       	ldi	r24, 0x2C	; 44
 790:	90 e0       	ldi	r25, 0x00	; 0
 792:	9c 83       	std	Y+4, r25	; 0x04
 794:	8b 83       	std	Y+3, r24	; 0x03
 796:	8b e2       	ldi	r24, 0x2B	; 43
 798:	90 e0       	ldi	r25, 0x00	; 0
 79a:	9e 83       	std	Y+6, r25	; 0x06
 79c:	8d 83       	std	Y+5, r24	; 0x05
 79e:	8a e2       	ldi	r24, 0x2A	; 42
 7a0:	90 e0       	ldi	r25, 0x00	; 0
 7a2:	98 87       	std	Y+8, r25	; 0x08
 7a4:	8f 83       	std	Y+7, r24	; 0x07
 7a6:	88 e1       	ldi	r24, 0x18	; 24
 7a8:	8a b9       	out	0x0a, r24	; 10
 7aa:	86 e8       	ldi	r24, 0x86	; 134
 7ac:	80 93 95 00 	sts	0x0095, r24
 7b0:	10 92 90 00 	sts	0x0090, r1
 7b4:	09 b9       	out	0x09, r16	; 9
 7b6:	16 c0       	rjmp	.+44     	; 0x7e4 <_ZN5rs232C1Ehh+0x74>
 7b8:	8c e9       	ldi	r24, 0x9C	; 156
 7ba:	90 e0       	ldi	r25, 0x00	; 0
 7bc:	9c 83       	std	Y+4, r25	; 0x04
 7be:	8b 83       	std	Y+3, r24	; 0x03
 7c0:	8b e9       	ldi	r24, 0x9B	; 155
 7c2:	90 e0       	ldi	r25, 0x00	; 0
 7c4:	9e 83       	std	Y+6, r25	; 0x06
 7c6:	8d 83       	std	Y+5, r24	; 0x05
 7c8:	8a e9       	ldi	r24, 0x9A	; 154
 7ca:	90 e0       	ldi	r25, 0x00	; 0
 7cc:	98 87       	std	Y+8, r25	; 0x08
 7ce:	8f 83       	std	Y+7, r24	; 0x07
 7d0:	88 e1       	ldi	r24, 0x18	; 24
 7d2:	80 93 9a 00 	sts	0x009A, r24
 7d6:	86 e8       	ldi	r24, 0x86	; 134
 7d8:	80 93 9d 00 	sts	0x009D, r24
 7dc:	10 92 98 00 	sts	0x0098, r1
 7e0:	00 93 99 00 	sts	0x0099, r16
 7e4:	eb 81       	ldd	r30, Y+3	; 0x03
 7e6:	fc 81       	ldd	r31, Y+4	; 0x04
 7e8:	80 81       	ld	r24, Z
 7ea:	80 81       	ld	r24, Z
 7ec:	df 91       	pop	r29
 7ee:	cf 91       	pop	r28
 7f0:	1f 91       	pop	r17
 7f2:	0f 91       	pop	r16
 7f4:	08 95       	ret

000007f6 <_ZN5rs232C2Ehh>:
 7f6:	0f 93       	push	r16
 7f8:	1f 93       	push	r17
 7fa:	cf 93       	push	r28
 7fc:	df 93       	push	r29
 7fe:	ec 01       	movw	r28, r24
 800:	06 2f       	mov	r16, r22
 802:	14 2f       	mov	r17, r20
 804:	0e 94 a8 00 	call	0x150	; 0x150 <_ZN16base_text_serialC2Ev>
 808:	8f e4       	ldi	r24, 0x4F	; 79
 80a:	91 e0       	ldi	r25, 0x01	; 1
 80c:	99 83       	std	Y+1, r25	; 0x01
 80e:	88 83       	st	Y, r24
 810:	11 23       	and	r17, r17
 812:	a9 f4       	brne	.+42     	; 0x83e <_ZN5rs232C2Ehh+0x48>
 814:	8c e2       	ldi	r24, 0x2C	; 44
 816:	90 e0       	ldi	r25, 0x00	; 0
 818:	9c 83       	std	Y+4, r25	; 0x04
 81a:	8b 83       	std	Y+3, r24	; 0x03
 81c:	8b e2       	ldi	r24, 0x2B	; 43
 81e:	90 e0       	ldi	r25, 0x00	; 0
 820:	9e 83       	std	Y+6, r25	; 0x06
 822:	8d 83       	std	Y+5, r24	; 0x05
 824:	8a e2       	ldi	r24, 0x2A	; 42
 826:	90 e0       	ldi	r25, 0x00	; 0
 828:	98 87       	std	Y+8, r25	; 0x08
 82a:	8f 83       	std	Y+7, r24	; 0x07
 82c:	88 e1       	ldi	r24, 0x18	; 24
 82e:	8a b9       	out	0x0a, r24	; 10
 830:	86 e8       	ldi	r24, 0x86	; 134
 832:	80 93 95 00 	sts	0x0095, r24
 836:	10 92 90 00 	sts	0x0090, r1
 83a:	09 b9       	out	0x09, r16	; 9
 83c:	16 c0       	rjmp	.+44     	; 0x86a <_ZN5rs232C2Ehh+0x74>
 83e:	8c e9       	ldi	r24, 0x9C	; 156
 840:	90 e0       	ldi	r25, 0x00	; 0
 842:	9c 83       	std	Y+4, r25	; 0x04
 844:	8b 83       	std	Y+3, r24	; 0x03
 846:	8b e9       	ldi	r24, 0x9B	; 155
 848:	90 e0       	ldi	r25, 0x00	; 0
 84a:	9e 83       	std	Y+6, r25	; 0x06
 84c:	8d 83       	std	Y+5, r24	; 0x05
 84e:	8a e9       	ldi	r24, 0x9A	; 154
 850:	90 e0       	ldi	r25, 0x00	; 0
 852:	98 87       	std	Y+8, r25	; 0x08
 854:	8f 83       	std	Y+7, r24	; 0x07
 856:	88 e1       	ldi	r24, 0x18	; 24
 858:	80 93 9a 00 	sts	0x009A, r24
 85c:	86 e8       	ldi	r24, 0x86	; 134
 85e:	80 93 9d 00 	sts	0x009D, r24
 862:	10 92 98 00 	sts	0x0098, r1
 866:	00 93 99 00 	sts	0x0099, r16
 86a:	eb 81       	ldd	r30, Y+3	; 0x03
 86c:	fc 81       	ldd	r31, Y+4	; 0x04
 86e:	80 81       	ld	r24, Z
 870:	80 81       	ld	r24, Z
 872:	df 91       	pop	r29
 874:	cf 91       	pop	r28
 876:	1f 91       	pop	r17
 878:	0f 91       	pop	r16
 87a:	08 95       	ret

0000087c <_ZN7avr_adcC1EP16base_text_serial>:
 *  describes how it does that once you've written the constructor. 
 *  @param p_serial_port A pointer to the serial port which writes debugging info. 
 */

avr_adc::avr_adc (base_text_serial* p_serial_port)
 87c:	fc 01       	movw	r30, r24
 87e:	cb 01       	movw	r24, r22
    {
    ptr_to_serial = p_serial_port;          // Store the serial port pointer locally
 880:	71 83       	std	Z+1, r23	; 0x01
 882:	60 83       	st	Z, r22

    // Note that ptr_to_serial is a pointer; the "*" is needed to indicate "the serial
    // port which is pointed to by the pointer" 
    *ptr_to_serial << "Setting up AVR A/D converter" << endl;
 884:	6b e5       	ldi	r22, 0x5B	; 91
 886:	71 e0       	ldi	r23, 0x01	; 1
 888:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 88c:	64 e0       	ldi	r22, 0x04	; 4
 88e:	70 e0       	ldi	r23, 0x00	; 0
 890:	0e 94 f5 00 	call	0x1ea	; 0x1ea <_ZN16base_text_seriallsE15ser_manipulator>

    // Initializes A/D converter to channel 0
    ADMUX = 0b00000000;
 894:	17 b8       	out	0x07, r1	; 7

    // Turns on A/D converter without interrupts or anything, with prescaler set to 16
    ADCSRA = 0b10000100;
 896:	84 e8       	ldi	r24, 0x84	; 132
 898:	86 b9       	out	0x06, r24	; 6
 89a:	08 95       	ret

0000089c <_ZN7avr_adcC2EP16base_text_serial>:
 89c:	fc 01       	movw	r30, r24
 89e:	cb 01       	movw	r24, r22
 8a0:	71 83       	std	Z+1, r23	; 0x01
 8a2:	60 83       	st	Z, r22
 8a4:	6b e5       	ldi	r22, 0x5B	; 91
 8a6:	71 e0       	ldi	r23, 0x01	; 1
 8a8:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 8ac:	64 e0       	ldi	r22, 0x04	; 4
 8ae:	70 e0       	ldi	r23, 0x00	; 0
 8b0:	0e 94 f5 00 	call	0x1ea	; 0x1ea <_ZN16base_text_seriallsE15ser_manipulator>
 8b4:	17 b8       	out	0x07, r1	; 7
 8b6:	84 e8       	ldi	r24, 0x84	; 132
 8b8:	86 b9       	out	0x06, r24	; 6
 8ba:	08 95       	ret

000008bc <_ZN7avr_adc9read_onceEh>:
    }


//-------------------------------------------------------------------------------------
/** This method takes one A/D reading from the given channel, and...?
 *  \param  channel The A/D channel which is being read must be from 0 to 7
 *  \return The result of the A/D conversion, or 0xFFFF if there was a timeout
 */

unsigned int avr_adc::read_once (unsigned char channel)
 8bc:	ef 92       	push	r14
 8be:	ff 92       	push	r15
 8c0:	1f 93       	push	r17
 8c2:	cf 93       	push	r28
 8c4:	df 93       	push	r29
 8c6:	ec 01       	movw	r28, r24
 8c8:	16 2f       	mov	r17, r22
    {
    *ptr_to_serial << "Running avr_adc::read_once()" << endl;
 8ca:	68 e7       	ldi	r22, 0x78	; 120
 8cc:	71 e0       	ldi	r23, 0x01	; 1
 8ce:	88 81       	ld	r24, Y
 8d0:	99 81       	ldd	r25, Y+1	; 0x01
 8d2:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 8d6:	64 e0       	ldi	r22, 0x04	; 4
 8d8:	70 e0       	ldi	r23, 0x00	; 0
 8da:	0e 94 f5 00 	call	0x1ea	; 0x1ea <_ZN16base_text_seriallsE15ser_manipulator>
    if(channel > 7){
 8de:	18 30       	cpi	r17, 0x08	; 8
 8e0:	68 f4       	brcc	.+26     	; 0x8fc <_ZN7avr_adc9read_onceEh+0x40>
	    *ptr_to_serial << "Channel must be between 0 and 7";
    }
    else{
    ADMUX |= channel;
 8e2:	87 b1       	in	r24, 0x07	; 7
 8e4:	81 2b       	or	r24, r17
 8e6:	87 b9       	out	0x07, r24	; 7
    }

    // reads from the selected channel, into ADCH and ADCL
    ADCSRA |= 0b01000000;
 8e8:	36 9a       	sbi	0x06, 6	; 6

    int while_counter = 0;
    
    while(ADCSRA & 0b01000000){
 8ea:	36 9b       	sbis	0x06, 6	; 6
 8ec:	10 c0       	rjmp	.+32     	; 0x90e <_ZN7avr_adc9read_onceEh+0x52>
 8ee:	60 e0       	ldi	r22, 0x00	; 0
 8f0:	70 e0       	ldi	r23, 0x00	; 0
	    while_counter++;
 8f2:	6f 5f       	subi	r22, 0xFF	; 255
 8f4:	7f 4f       	sbci	r23, 0xFF	; 255
 8f6:	36 99       	sbic	0x06, 6	; 6
 8f8:	fc cf       	rjmp	.-8      	; 0x8f2 <_ZN7avr_adc9read_onceEh+0x36>
 8fa:	0b c0       	rjmp	.+22     	; 0x912 <_ZN7avr_adc9read_onceEh+0x56>
 8fc:	65 e9       	ldi	r22, 0x95	; 149
 8fe:	71 e0       	ldi	r23, 0x01	; 1
 900:	88 81       	ld	r24, Y
 902:	99 81       	ldd	r25, Y+1	; 0x01
 904:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 908:	36 9a       	sbi	0x06, 6	; 6
 90a:	36 99       	sbic	0x06, 6	; 6
 90c:	f0 cf       	rjmp	.-32     	; 0x8ee <_ZN7avr_adc9read_onceEh+0x32>
 90e:	60 e0       	ldi	r22, 0x00	; 0
 910:	70 e0       	ldi	r23, 0x00	; 0
    }
    
    *ptr_to_serial << while_counter;
 912:	88 81       	ld	r24, Y
 914:	99 81       	ldd	r25, Y+1	; 0x01
 916:	0e 94 2c 01 	call	0x258	; 0x258 <_ZN16base_text_seriallsEi>
    while_counter = 0;
    ADC_result result;

    result.bytes[0] = ADCL;
 91a:	84 b1       	in	r24, 0x04	; 4
 91c:	e8 2e       	mov	r14, r24
    result.bytes[1] = ADCH;
 91e:	15 b1       	in	r17, 0x05	; 5
 920:	f1 2e       	mov	r15, r17

    *ptr_to_serial << hex << "\n\rADCL: " << result.bytes[0] << "\n\rADCH: " << result.bytes[1] << endl;
 922:	63 e0       	ldi	r22, 0x03	; 3
 924:	70 e0       	ldi	r23, 0x00	; 0
 926:	88 81       	ld	r24, Y
 928:	99 81       	ldd	r25, Y+1	; 0x01
 92a:	0e 94 f5 00 	call	0x1ea	; 0x1ea <_ZN16base_text_seriallsE15ser_manipulator>
 92e:	65 eb       	ldi	r22, 0xB5	; 181
 930:	71 e0       	ldi	r23, 0x01	; 1
 932:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 936:	6e 2d       	mov	r22, r14
 938:	0e 94 ee 01 	call	0x3dc	; 0x3dc <_ZN16base_text_seriallsEc>
 93c:	6e eb       	ldi	r22, 0xBE	; 190
 93e:	71 e0       	ldi	r23, 0x01	; 1
 940:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 944:	61 2f       	mov	r22, r17
 946:	0e 94 ee 01 	call	0x3dc	; 0x3dc <_ZN16base_text_seriallsEc>
 94a:	64 e0       	ldi	r22, 0x04	; 4
 94c:	70 e0       	ldi	r23, 0x00	; 0
 94e:	0e 94 f5 00 	call	0x1ea	; 0x1ea <_ZN16base_text_seriallsE15ser_manipulator>

    return result.word;
    }
 952:	c7 01       	movw	r24, r14
 954:	df 91       	pop	r29
 956:	cf 91       	pop	r28
 958:	1f 91       	pop	r17
 95a:	ff 90       	pop	r15
 95c:	ef 90       	pop	r14
 95e:	08 95       	ret

00000960 <_ZlsR16base_text_serialR7avr_adc>:


//--------------------------------------------------------------------------------------
/** This overloaded operator allows information about or from an A/D converter to be 
 *  printed on a serial device such as a regular serial port or radio module in text 
 *  mode, which is extremely convenient for debugging. 
 *  @param serial A reference to the serial-type object to which to print
 *  @param stamp A reference to the time stamp to be displayed
 */

base_text_serial& operator<< (base_text_serial& serial, avr_adc& my_adc)
 960:	6f 92       	push	r6
 962:	7f 92       	push	r7
 964:	8f 92       	push	r8
 966:	9f 92       	push	r9
 968:	af 92       	push	r10
 96a:	bf 92       	push	r11
 96c:	cf 92       	push	r12
 96e:	df 92       	push	r13
 970:	ef 92       	push	r14
 972:	ff 92       	push	r15
 974:	0f 93       	push	r16
 976:	1f 93       	push	r17
 978:	3c 01       	movw	r6, r24
 97a:	8b 01       	movw	r16, r22
    {
    unsigned int channel0, channel1, channel2, channel3;
    channel0 = my_adc.read_once(0);
 97c:	60 e0       	ldi	r22, 0x00	; 0
 97e:	c8 01       	movw	r24, r16
 980:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_ZN7avr_adc9read_onceEh>
 984:	7c 01       	movw	r14, r24
    channel1 = my_adc.read_once(1);
 986:	61 e0       	ldi	r22, 0x01	; 1
 988:	c8 01       	movw	r24, r16
 98a:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_ZN7avr_adc9read_onceEh>
 98e:	6c 01       	movw	r12, r24
    channel2 = my_adc.read_once(2);
 990:	62 e0       	ldi	r22, 0x02	; 2
 992:	c8 01       	movw	r24, r16
 994:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_ZN7avr_adc9read_onceEh>
 998:	5c 01       	movw	r10, r24
    channel3 = my_adc.read_once(3);
 99a:	63 e0       	ldi	r22, 0x03	; 3
 99c:	c8 01       	movw	r24, r16
 99e:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_ZN7avr_adc9read_onceEh>
 9a2:	4c 01       	movw	r8, r24
    serial << "A/D registers of interest: \n\rADMUX: " << ADMUX << "\n\rADCSRA: " << ADCSRA <<
	    "\n\rCurrent value of channels:\n\rChannel 0: " << channel0 << "\n\rChannel 1: " << channel1 <<
	    "\n\rChannel 2: " << channel2 << "\n\rChannel 3: " << channel3 << endl;
 9a4:	06 b1       	in	r16, 0x06	; 6
 9a6:	17 b1       	in	r17, 0x07	; 7
 9a8:	67 ec       	ldi	r22, 0xC7	; 199
 9aa:	71 e0       	ldi	r23, 0x01	; 1
 9ac:	c3 01       	movw	r24, r6
 9ae:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 9b2:	61 2f       	mov	r22, r17
 9b4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <_ZN16base_text_seriallsEh>
 9b8:	6c ee       	ldi	r22, 0xEC	; 236
 9ba:	71 e0       	ldi	r23, 0x01	; 1
 9bc:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 9c0:	60 2f       	mov	r22, r16
 9c2:	0e 94 52 02 	call	0x4a4	; 0x4a4 <_ZN16base_text_seriallsEh>
 9c6:	67 ef       	ldi	r22, 0xF7	; 247
 9c8:	71 e0       	ldi	r23, 0x01	; 1
 9ca:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 9ce:	b7 01       	movw	r22, r14
 9d0:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN16base_text_seriallsEj>
 9d4:	61 e2       	ldi	r22, 0x21	; 33
 9d6:	72 e0       	ldi	r23, 0x02	; 2
 9d8:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 9dc:	b6 01       	movw	r22, r12
 9de:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN16base_text_seriallsEj>
 9e2:	6f e2       	ldi	r22, 0x2F	; 47
 9e4:	72 e0       	ldi	r23, 0x02	; 2
 9e6:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 9ea:	b5 01       	movw	r22, r10
 9ec:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN16base_text_seriallsEj>
 9f0:	6d e3       	ldi	r22, 0x3D	; 61
 9f2:	72 e0       	ldi	r23, 0x02	; 2
 9f4:	0e 94 c2 00 	call	0x184	; 0x184 <_ZN16base_text_seriallsEPKc>
 9f8:	b4 01       	movw	r22, r8
 9fa:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN16base_text_seriallsEj>
 9fe:	64 e0       	ldi	r22, 0x04	; 4
 a00:	70 e0       	ldi	r23, 0x00	; 0
 a02:	0e 94 f5 00 	call	0x1ea	; 0x1ea <_ZN16base_text_seriallsE15ser_manipulator>

    return (serial);
    }
 a06:	c3 01       	movw	r24, r6
 a08:	1f 91       	pop	r17
 a0a:	0f 91       	pop	r16
 a0c:	ff 90       	pop	r15
 a0e:	ef 90       	pop	r14
 a10:	df 90       	pop	r13
 a12:	cf 90       	pop	r12
 a14:	bf 90       	pop	r11
 a16:	af 90       	pop	r10
 a18:	9f 90       	pop	r9
 a1a:	8f 90       	pop	r8
 a1c:	7f 90       	pop	r7
 a1e:	6f 90       	pop	r6
 a20:	08 95       	ret

00000a22 <ltoa>:
 a22:	fa 01       	movw	r30, r20
 a24:	cf 93       	push	r28
 a26:	ff 93       	push	r31
 a28:	ef 93       	push	r30
 a2a:	22 30       	cpi	r18, 0x02	; 2
 a2c:	44 f1       	brlt	.+80     	; 0xa7e <ltoa+0x5c>
 a2e:	25 32       	cpi	r18, 0x25	; 37
 a30:	34 f5       	brge	.+76     	; 0xa7e <ltoa+0x5c>
 a32:	c2 2f       	mov	r28, r18
 a34:	e8 94       	clt
 a36:	ca 30       	cpi	r28, 0x0A	; 10
 a38:	49 f4       	brne	.+18     	; 0xa4c <ltoa+0x2a>
 a3a:	97 fb       	bst	r25, 7
 a3c:	3e f4       	brtc	.+14     	; 0xa4c <ltoa+0x2a>
 a3e:	90 95       	com	r25
 a40:	80 95       	com	r24
 a42:	70 95       	com	r23
 a44:	61 95       	neg	r22
 a46:	7f 4f       	sbci	r23, 0xFF	; 255
 a48:	8f 4f       	sbci	r24, 0xFF	; 255
 a4a:	9f 4f       	sbci	r25, 0xFF	; 255
 a4c:	2c 2f       	mov	r18, r28
 a4e:	33 27       	eor	r19, r19
 a50:	44 27       	eor	r20, r20
 a52:	55 27       	eor	r21, r21
 a54:	ff 93       	push	r31
 a56:	ef 93       	push	r30
 a58:	0e 94 a4 05 	call	0xb48	; 0xb48 <__udivmodsi4>
 a5c:	ef 91       	pop	r30
 a5e:	ff 91       	pop	r31
 a60:	60 5d       	subi	r22, 0xD0	; 208
 a62:	6a 33       	cpi	r22, 0x3A	; 58
 a64:	0c f0       	brlt	.+2      	; 0xa68 <ltoa+0x46>
 a66:	69 5d       	subi	r22, 0xD9	; 217
 a68:	61 93       	st	Z+, r22
 a6a:	b9 01       	movw	r22, r18
 a6c:	ca 01       	movw	r24, r20
 a6e:	60 50       	subi	r22, 0x00	; 0
 a70:	70 40       	sbci	r23, 0x00	; 0
 a72:	80 40       	sbci	r24, 0x00	; 0
 a74:	90 40       	sbci	r25, 0x00	; 0
 a76:	51 f7       	brne	.-44     	; 0xa4c <ltoa+0x2a>
 a78:	16 f4       	brtc	.+4      	; 0xa7e <ltoa+0x5c>
 a7a:	cd e2       	ldi	r28, 0x2D	; 45
 a7c:	c1 93       	st	Z+, r28
 a7e:	10 82       	st	Z, r1
 a80:	8f 91       	pop	r24
 a82:	9f 91       	pop	r25
 a84:	cf 91       	pop	r28
 a86:	0c 94 80 05 	jmp	0xb00	; 0xb00 <strrev>

00000a8a <ultoa>:
 a8a:	fa 01       	movw	r30, r20
 a8c:	cf 93       	push	r28
 a8e:	ff 93       	push	r31
 a90:	ef 93       	push	r30
 a92:	22 30       	cpi	r18, 0x02	; 2
 a94:	cc f0       	brlt	.+50     	; 0xac8 <ultoa+0x3e>
 a96:	25 32       	cpi	r18, 0x25	; 37
 a98:	bc f4       	brge	.+46     	; 0xac8 <ultoa+0x3e>
 a9a:	c2 2f       	mov	r28, r18
 a9c:	2c 2f       	mov	r18, r28
 a9e:	33 27       	eor	r19, r19
 aa0:	44 27       	eor	r20, r20
 aa2:	55 27       	eor	r21, r21
 aa4:	ff 93       	push	r31
 aa6:	ef 93       	push	r30
 aa8:	0e 94 a4 05 	call	0xb48	; 0xb48 <__udivmodsi4>
 aac:	ef 91       	pop	r30
 aae:	ff 91       	pop	r31
 ab0:	60 5d       	subi	r22, 0xD0	; 208
 ab2:	6a 33       	cpi	r22, 0x3A	; 58
 ab4:	0c f0       	brlt	.+2      	; 0xab8 <ultoa+0x2e>
 ab6:	69 5d       	subi	r22, 0xD9	; 217
 ab8:	61 93       	st	Z+, r22
 aba:	b9 01       	movw	r22, r18
 abc:	ca 01       	movw	r24, r20
 abe:	60 50       	subi	r22, 0x00	; 0
 ac0:	70 40       	sbci	r23, 0x00	; 0
 ac2:	80 40       	sbci	r24, 0x00	; 0
 ac4:	90 40       	sbci	r25, 0x00	; 0
 ac6:	51 f7       	brne	.-44     	; 0xa9c <ultoa+0x12>
 ac8:	10 82       	st	Z, r1
 aca:	8f 91       	pop	r24
 acc:	9f 91       	pop	r25
 ace:	cf 91       	pop	r28
 ad0:	0c 94 80 05 	jmp	0xb00	; 0xb00 <strrev>

00000ad4 <utoa>:
 ad4:	fb 01       	movw	r30, r22
 ad6:	9f 01       	movw	r18, r30
 ad8:	42 30       	cpi	r20, 0x02	; 2
 ada:	74 f0       	brlt	.+28     	; 0xaf8 <utoa+0x24>
 adc:	45 32       	cpi	r20, 0x25	; 37
 ade:	64 f4       	brge	.+24     	; 0xaf8 <utoa+0x24>
 ae0:	64 2f       	mov	r22, r20
 ae2:	77 27       	eor	r23, r23
 ae4:	0e 94 90 05 	call	0xb20	; 0xb20 <__udivmodhi4>
 ae8:	80 5d       	subi	r24, 0xD0	; 208
 aea:	8a 33       	cpi	r24, 0x3A	; 58
 aec:	0c f0       	brlt	.+2      	; 0xaf0 <utoa+0x1c>
 aee:	89 5d       	subi	r24, 0xD9	; 217
 af0:	81 93       	st	Z+, r24
 af2:	cb 01       	movw	r24, r22
 af4:	00 97       	sbiw	r24, 0x00	; 0
 af6:	a1 f7       	brne	.-24     	; 0xae0 <utoa+0xc>
 af8:	10 82       	st	Z, r1
 afa:	c9 01       	movw	r24, r18
 afc:	0c 94 80 05 	jmp	0xb00	; 0xb00 <strrev>

00000b00 <strrev>:
 b00:	dc 01       	movw	r26, r24
 b02:	fc 01       	movw	r30, r24
 b04:	01 90       	ld	r0, Z+
 b06:	00 20       	and	r0, r0
 b08:	e9 f7       	brne	.-6      	; 0xb04 <strrev+0x4>
 b0a:	32 97       	sbiw	r30, 0x02	; 2
 b0c:	ae 17       	cp	r26, r30
 b0e:	bf 07       	cpc	r27, r31
 b10:	30 f4       	brcc	.+12     	; 0xb1e <strrev+0x1e>
 b12:	7c 91       	ld	r23, X
 b14:	60 81       	ld	r22, Z
 b16:	70 83       	st	Z, r23
 b18:	31 97       	sbiw	r30, 0x01	; 1
 b1a:	6d 93       	st	X+, r22
 b1c:	f7 cf       	rjmp	.-18     	; 0xb0c <strrev+0xc>
 b1e:	08 95       	ret

00000b20 <__udivmodhi4>:
 b20:	aa 1b       	sub	r26, r26
 b22:	bb 1b       	sub	r27, r27
 b24:	51 e1       	ldi	r21, 0x11	; 17
 b26:	07 c0       	rjmp	.+14     	; 0xb36 <__udivmodhi4_ep>

00000b28 <__udivmodhi4_loop>:
 b28:	aa 1f       	adc	r26, r26
 b2a:	bb 1f       	adc	r27, r27
 b2c:	a6 17       	cp	r26, r22
 b2e:	b7 07       	cpc	r27, r23
 b30:	10 f0       	brcs	.+4      	; 0xb36 <__udivmodhi4_ep>
 b32:	a6 1b       	sub	r26, r22
 b34:	b7 0b       	sbc	r27, r23

00000b36 <__udivmodhi4_ep>:
 b36:	88 1f       	adc	r24, r24
 b38:	99 1f       	adc	r25, r25
 b3a:	5a 95       	dec	r21
 b3c:	a9 f7       	brne	.-22     	; 0xb28 <__udivmodhi4_loop>
 b3e:	80 95       	com	r24
 b40:	90 95       	com	r25
 b42:	bc 01       	movw	r22, r24
 b44:	cd 01       	movw	r24, r26
 b46:	08 95       	ret

00000b48 <__udivmodsi4>:
 b48:	a1 e2       	ldi	r26, 0x21	; 33
 b4a:	1a 2e       	mov	r1, r26
 b4c:	aa 1b       	sub	r26, r26
 b4e:	bb 1b       	sub	r27, r27
 b50:	fd 01       	movw	r30, r26
 b52:	0d c0       	rjmp	.+26     	; 0xb6e <__udivmodsi4_ep>

00000b54 <__udivmodsi4_loop>:
 b54:	aa 1f       	adc	r26, r26
 b56:	bb 1f       	adc	r27, r27
 b58:	ee 1f       	adc	r30, r30
 b5a:	ff 1f       	adc	r31, r31
 b5c:	a2 17       	cp	r26, r18
 b5e:	b3 07       	cpc	r27, r19
 b60:	e4 07       	cpc	r30, r20
 b62:	f5 07       	cpc	r31, r21
 b64:	20 f0       	brcs	.+8      	; 0xb6e <__udivmodsi4_ep>
 b66:	a2 1b       	sub	r26, r18
 b68:	b3 0b       	sbc	r27, r19
 b6a:	e4 0b       	sbc	r30, r20
 b6c:	f5 0b       	sbc	r31, r21

00000b6e <__udivmodsi4_ep>:
 b6e:	66 1f       	adc	r22, r22
 b70:	77 1f       	adc	r23, r23
 b72:	88 1f       	adc	r24, r24
 b74:	99 1f       	adc	r25, r25
 b76:	1a 94       	dec	r1
 b78:	69 f7       	brne	.-38     	; 0xb54 <__udivmodsi4_loop>
 b7a:	60 95       	com	r22
 b7c:	70 95       	com	r23
 b7e:	80 95       	com	r24
 b80:	90 95       	com	r25
 b82:	9b 01       	movw	r18, r22
 b84:	ac 01       	movw	r20, r24
 b86:	bd 01       	movw	r22, r26
 b88:	cf 01       	movw	r24, r30
 b8a:	08 95       	ret
